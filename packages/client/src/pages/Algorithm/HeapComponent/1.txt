 var width = 600
var height = 300

function createtree(dataset){
  var len = dataset.length;
  var parr = [...Array(len-1).keys()];
  

  var svg = d3.select("body")     //选择文档中的body元素
    .append("svg")          //添加一个svg元素
    .attr("width", width)       //设定宽度
    .attr("height", height);    //设定高度
  
  var my = 60
  var p = svg.append("g")
    .attr("stroke","black")
    .attr("stroke-width","1")
    .selectAll("line")
    .data(dataset)
    .enter()
    .append("line")
    .attr("id",function(c){
      return "l"+c.index
    })
    .attr("x1", function(c){
      if(c.index==1)
      {
        return null
      }
      return getx(c.index)
    })
    .attr("y1", function(c){
      if(c.index==1)
      {
        return null
      }
      return my*(getdepth(c.index)+1)
    })
    .attr("x2", function(c){
      if(c.index==1)
      {
        return null
      }
      c = Math.floor(c.index/2)
      return getx(c)
    })
    .attr("y2", function(c){
      if(c.index==1)
      {
        return null
      }
      return my*(getdepth(c.index))
    })
  
  var c = svg.append("g")
    .attr("stroke","black")
    .attr("fill","white")
    .attr("stroke-width","1")
    .selectAll("circle")
    .data(dataset)
    .enter()
    .append("circle")
    .attr("id",function(c){
      return "c"+c.index
    })
    .attr("cx", function(c){
      return getx(c.index)
    })
    .attr("cy", function(c){
      return my*(getdepth(c.index)+1)
    })
    .attr("r",20)
  
  var t = svg.append("g")
    .attr("stroke","black")
    .attr("text-anchor","middle")
    .attr("text-size","10px")
    .selectAll("text")
    .data(dataset)
    .enter()
    .append("text")
    .attr("id",function(c){
      return "t"+c.index
    })
    .attr("dx", function(c){
      return getx(c.index)
    })
    .attr("dy", function(c){
      return my*(getdepth(c.index)+1)+5
    })
    .text(function(t){
      return t.value;
    })
    
    buildmaxheap()
  }
  
  function getdepth(c)
  {
      return Math.ceil(Math.log2(c+1))-1
  }
  
  function getx(c)
  {
      var depth = getdepth(c)
      var distance = 2**depth
      var index = c-(2**depth)
      return (width/(distance+1))*(index+1)
  }

  function createAndAppendAnimate(c1, attributeName, fromValue, toValue,c2) {
    const animateElement = document.createElementNS("http://www.w3.org/2000/svg", "animate");
    animateElement.setAttribute("id", c1.getAttribute("id")+c2.getAttribute("id") + attributeName);
    animateElement.setAttribute("attributeName", attributeName);
    animateElement.setAttribute("from", fromValue);
    animateElement.setAttribute("to", toValue);
    animateElement.setAttribute("start", "0s");
    animateElement.setAttribute("dur", "3s");
    animateElement.setAttribute("fill", "freeze");
    c1.appendChild(animateElement);
    animateElement.beginElement();
  }
  
  function addmove(c1, c2, x1, x2, y1, y2) {
    createAndAppendAnimate(c1, "dx", x1, x2,c2);
    createAndAppendAnimate(c1, "dy", y1, y2,c2);
  }
  
  function exchangetext(c1,c2){
    let x1 = c1.getAttribute("dx")
    let y1 = c1.getAttribute("dy")
    let x2 = c2.getAttribute("dx")
    let y2 = c2.getAttribute("dy")
    addmove(c1,c2,x1,x2,y1,y2)
    addmove(c2,c1,x2,x1,y2,y1)
    c1.setAttribute("dx",x2)
    c1.setAttribute("dy",y2)
    c2.setAttribute("dx",x1)
    c2.setAttribute("dy",y1)
  }
  
  function nextstep(record, step){
    if(step>=record.length)
      alert("The heap is end")
    else
    {
      const text1 = document.getElementById("t" + record[step].e1);
      const text2 = document.getElementById("t" + record[step].e2);
      exchangetext(text1, text2);
    }
  }

 function maxheap(dataset,i){
    let left = i*2
    let right = i*2+1
    let largest = 0;
    if(left <= dataset.length && dataset[left-1].value > dataset[i-1].value)
      largest = left
    else
      largest = i
  
    if(right <= dataset.length && dataset[right-1].value > dataset[largest-1].value)
      largest = right
    if(i!=largest)
    {
      record.push({e1:dataset[i-1].index, e2:dataset[largest-1].index})
      let t = dataset[i-1]
      dataset[i-1] = dataset[largest-1]
      dataset[largest-1] = t
      maxheap(dataset,largest)
    }
  }

function buildmaxheap(){
  for(var i = Math.floor(dataset.length/2) ;i>0;i--)
  {
    maxheap(dataset,i)
  }
}

function insertheap(dataset, newValue) {
  data.push(Number(newValue))
  dataset.push({ index: dataset.length + 1, value: newValue });

  // Get the index of the newly added element.
  let currentIndex = dataset.length;

  // Heapify: Move the new element up the tree to maintain the max-heap property.
  while (currentIndex > 1) {
    const parentIndex = Math.floor(currentIndex / 2) - 1;

    if (dataset[currentIndex - 1].value > dataset[parentIndex].value) {
      // Swap the current element with its parent.
      const temp = dataset[currentIndex - 1];
      dataset[currentIndex - 1] = dataset[parentIndex];
      dataset[parentIndex] = temp;

      // Update the record with the swap information.
      record.push({ e1: dataset[currentIndex - 1].index, e2: dataset[parentIndex].index });

      // Move up to the parent index.
      currentIndex = parentIndex + 1;
    } else {
      // The max-heap property is satisfied; no need to swap further.
      break;
    }
  }
}
  
  function insert(value){
    data.push(value)
    datatran(data)
  }


  var data = [18, 4, 10, 13, 7, 9, 3, 2, 8, 1];
//var data = [4,13,7,2,8,1]
var dataset = [];
var record = [];

function datatran(data){
  dataset = []
  for (let i = 1; i <= data.length; ++i) {
    dataset[i-1] = { index: i, value: Number(data[i-1]) };
  }
  return dataset
}

function validdata(tdata){
  for (const ele of tdata) {
    if (isNaN(ele)) {
      return false; // Return false if any element is not a valid number
    }
  }
  return true
}

function reset(){
  d3.select('svg').remove();
  datatran(data)
  createtree(dataset)
}

window.addEventListener("DOMContentLoaded", event => {
  var step = 0;
  datatran(data)
  createtree(dataset)

  document.getElementById("csubmit").addEventListener("click",function(){
    
    let tdata = document.getElementById("create").value.split(",");
    if(validdata(tdata))
    {
      data = []
      data = tdata
      record = []
      d3.select('svg').remove();
      datatran(data)
      dataset.forEach(element => {
        console.log(element)
      });
      createtree(dataset)
      step = 0;
    }
    else
    {
      alert("Only numbers and commas can be entered")
    }
  })

  document.getElementById("isubmit").addEventListener("click",function(){
    
    let tdata = document.getElementById("insert").value.split(",");
    if(validdata(tdata))
    {
      if(tdata.length==1)
      {
        insertheap(dataset,tdata[0])
        d3.select('svg').remove();
        dataset.forEach(element => {
        console.log(element)
      });
      createtree(dataset)
      step = 0;
      }
      else
      {
        alert("Only insert one number")
      }
    }
    else
    {
      alert("Only numbers and commas can be entered")
    }
    
  })

  document.getElementById("nextstep").addEventListener("click",function(event){
    nextstep(record,step)
    step = step+1
  })
  document.getElementById("reset").addEventListener("click",function(event){
    reset()
    step = step+1
  })
})